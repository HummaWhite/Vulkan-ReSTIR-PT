#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "ray_layouts.glsl"
#include "camera.glsl"
#include "gbuffer_util.glsl"
#include "light_sampling.glsl"
#include "math.glsl"

layout(location = ClosestHitPayloadLocation) rayPayloadEXT Intersection rtIsec;
layout(location = ShadowPayloadLocation) rayPayloadEXT bool rtShadowed;

vec3 BSDFDot(vec3 albedo, vec3 n, vec3 wi) {
    return albedo * PiInv * satDot(n, wi);
}

void main() {
    uvec2 index = gl_LaunchIDEXT.xy;
    vec2 uv = (vec2(index) + 0.5) / vec2(gl_LaunchSizeEXT.xy);

    vec4 depthNormal = texture(uDepthNormal, uv);
    float depth = depthNormal.x;
    vec3 norm = depthNormal.yzw;

    if (depth == 0.0) {
        imageStore(uDirectOutput, ivec2(index), vec4(vec3(0.0), 1.0));
        return;
    }
    uvec2 albedoMatId = texelFetch(uAlbedoMatId, ivec2(index), 0).rg;
    vec3 albedo = unpackAlbedo(albedoMatId.x);
    int matMeshId = int(albedoMatId.y);
    int matId = matMeshId >> 16;
    
    Ray ray = pinholeCameraSampleRay(uCamera, vec2(uv.x, 1.0 - uv.y), vec2(0));
    uint rng = makeSeed(uCamera.seed + gl_LaunchIDEXT.x, gl_LaunchIDEXT.y);

    vec3 radiance = vec3(0.0);

    vec3 pos = ray.ori + ray.dir * (depth - 1e-4);

    if (/* sample direct lighting */ true) {
        const uint shadowRayFlags = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT;

        vec3 lightRadiance, lightDir;
        float lightDist, lightPdf;

        rtShadowed = true;
        lightRadiance = sampleLight(pos, lightDir, lightDist, lightPdf, rng);

        traceRayEXT(
            /* AS, flags, masks    */ uTLAS, shadowRayFlags, 0xff,
            /* SBT offset & stride */ 0, 0,
            /* miss index          */ 1,
            /* ray attribs         */ pos, MinRayDistance, lightDir, lightDist - 1e-4,
            /* payload location    */ ShadowPayloadLocation
        );

        if (!rtShadowed && lightPdf > 1e-6) {
            float bsdfPdf = absDot(norm, lightDir) * PiInv;
            float weight = MISWeight(lightPdf, bsdfPdf);
            radiance = lightRadiance * BSDFDot(albedo, norm, lightDir) / lightPdf;
        }
    }
    radiance = clampColor(radiance);

    float frameCount = float(uCamera.frameIndex);
    vec3 accumulatedRadaince = imageLoad(uDirectOutput, ivec2(index)).rgb;
    accumulatedRadaince = (accumulatedRadaince * frameCount + radiance) / (frameCount + 1.0);

    imageStore(uDirectOutput, ivec2(index), vec4(accumulatedRadaince, 1.0));
}