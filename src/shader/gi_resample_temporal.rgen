#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "ray_layouts.glsl"
#include "camera.glsl"
#include "gbuffer_util.glsl"
#include "light_sampling.glsl"
#include "gi_reservoir.glsl"

layout(location = ClosestHitPayloadLocation) rayPayloadEXT Intersection rtIsec;
layout(location = ShadowPayloadLocation) rayPayloadEXT bool rtShadowed;

bool findPreviousReservoir(vec2 uv, vec3 pos, float depth, vec3 normal, vec3 albedo, int matMeshId, out GIReservoir resv) {
    if (uv.x < 0 || uv.y < 0 || uv.x > 1.0 || uv.y > 1.0) {
        return false;
    }
    ivec2 pixelId = ivec2(uv * vec2(gl_LaunchSizeEXT.xy));

    vec4 depthNormalPrev = texture(uDepthNormal, uv);
    uvec2 albedoMatIdPrev = texelFetch(uAlbedoMatIdPrev, pixelId, 0).rg;
    
    float depthPrev = depthNormalPrev.x;
    vec3 normalPrev = depthNormalPrev.yzw;
    vec3 albedoPrev = unpackAlbedo(albedoMatIdPrev.x);
    int matMeshIdPrev = int(albedoMatIdPrev.y);

    Ray ray = pinholeCameraSampleRay(uPrevCamera, vec2(uv.x, 1.0 - uv.y), vec2(0));
    vec3 posPrev = ray.ori + ray.dir * (depthPrev - 1e-4);

    if (matMeshIdPrev != matMeshId || dot(normalPrev, normal) < 0.9 || abs(depthPrev - depth) > 5.0) {
        return false;
    }
    resv = uGIReservoirPrev[index1D(uvec2(pixelId))];
    return true;
}

void main() {
    const int MaxTracingDepth = 3;
    uvec2 index = gl_LaunchIDEXT.xy;
    vec2 uv = (vec2(index) + 0.5) / vec2(gl_LaunchSizeEXT.xy);

    vec4 depthNormal = texture(uDepthNormal, uv);
    float depth = depthNormal.x;
    vec3 norm = depthNormal.yzw;

    if (depth == 0.0) {
        imageStore(uIndirectOutput, ivec2(index), vec4(vec3(0.0), 1.0));
        GIReservoirReset(uGIReservoir[index1D(index)]);
        return;
    }
    uvec2 albedoMatId = texelFetch(uAlbedoMatId, ivec2(index), 0).rg;
    vec3 albedo = unpackAlbedo(albedoMatId.x);
    int matMeshId = int(albedoMatId.y);
    int matId = matMeshId >> 16;
    vec2 motion = texelFetch(uMotionVector, ivec2(index), 0).xy;
    
    Ray ray = pinholeCameraSampleRay(uCamera, vec2(uv.x, 1.0 - uv.y), vec2(0));
    //uint rng = makeSeed(uCamera.frameIndex, uCamera.seed, hash2(index.x) + index.y);
    uint rng = makeSeed(uCamera.seed + gl_LaunchIDEXT.x, gl_LaunchIDEXT.y);

    vec3 throughput = vec3(1.0);
    vec3 lastPos;
    float lastBsdfPdf;

    SurfaceInfo surf;
    surf.pos = ray.ori + ray.dir * (depth - 1e-4);
    surf.norm = norm;
    surf.albedo = albedo;
    surf.isLight = false;
    rtIsec.hit = true;

    GIPathSample pathSample = GIPathSampleInit();
    pathSample.visiblePos = surf.pos;
    pathSample.visibleNorm = surf.norm;
    
    vec3 primaryPos = surf.pos;
    vec3 primaryWo = -ray.dir;
    vec3 primaryAlbedo = albedo;
    float primaryPdf;
    int primMatId = matId;

#pragma unroll
    for (int bounce = 0; bounce < MaxTracingDepth; bounce++) {
        if (bounce > 0) {
            rtIsec.hit = false;

            traceRayEXT(
                /* AS, flags, masks    */ uTLAS, gl_RayFlagsOpaqueEXT, 0xff,
                /* SBT offset & stride */ 0, 0,
                /* miss index          */ 0,
                /* ray attribs         */ ray.ori, MinRayDistance, ray.dir, MaxRayDistance,
                /* payload location    */ ClosestHitPayloadLocation
            );

            if (!rtIsec.hit) {
                break;
            }
            loadSurfaceInfo(rtIsec, surf);

            if (bounce == 1) {
                pathSample.sampledPos = surf.pos;
                pathSample.sampledNorm = surf.norm;
            }
        }

        if (surf.isLight) {
            float cosTheta = -dot(ray.dir, surf.norm);

            if (cosTheta > 0) {
                float weight = 1.0;

                if (bounce > 0) {
                    float dist = length(surf.pos - lastPos);
                    float sumPower = uLightSampleTable[0].prob;
                    float lightPdf = luminance(surf.albedo) / sumPower * dist * dist / cosTheta;
                    weight = MISWeight(lastBsdfPdf, lightPdf);
                }
                weight = 1.0;
                pathSample.radiance += surf.albedo * weight * throughput;
            }
            break;
        }

        if (/* sample light sources */ bounce > 0)
        {
            const uint shadowRayFlags = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT;

            vec3 lightRadiance, lightDir;
            float lightDist, lightPdf;

            rtShadowed = true;
            lightRadiance = sampleLight(surf.pos, lightDir, lightDist, lightPdf, rng);

            traceRayEXT(
                /* AS, flags, masks    */ uTLAS, shadowRayFlags, 0xff,
                /* SBT offset & stride */ 0, 0,
                /* miss index          */ 1,
                /* ray attribs         */ surf.pos, MinRayDistance, lightDir, lightDist - 1e-4,
                /* payload location    */ ShadowPayloadLocation
            );

            if (!rtShadowed && lightPdf > 1e-6) {
                float bsdfPdf = absDot(surf.norm, lightDir) * PiInv;
                float weight = MISWeight(lightPdf, bsdfPdf);
                weight = 0.0;
                pathSample.radiance += lightRadiance * (surf.albedo * PiInv) * satDot(surf.norm, lightDir) / lightPdf * weight * throughput;
            }
        }

        ray.dir = sampleCosineWeightedHemisphere(surf.norm, sample2f(rng));
        ray.ori = surf.pos + ray.dir * 1e-4;

        if (bounce == 0) {
            primaryPdf = dot(surf.norm, ray.dir) * PiInv;
            surf.albedo = vec3(1.0);
        }

        throughput *= surf.albedo;
        lastBsdfPdf = absDot(surf.norm, ray.dir) * PiInv;
        lastPos = surf.pos;
    }
    vec3 radiance = pathSample.radiance;

    GIReservoir resv;
    GIReservoirReset(resv);
    
    if (true) {
        findPreviousReservoir(uv + motion, primaryPos, depth, norm, albedo, matMeshId, resv);
        float sampleWeight = 0.0;

        if (GIPathSampleIsValid(pathSample) && primaryPdf > 1e-6) {
            float pHat = GIPathSamplePHat(pathSample);
            sampleWeight = pHat / primaryPdf;

            if (isnan(sampleWeight) || sampleWeight < 0.0) {
                sampleWeight = 0.0;
            }
            GIReservoirAddSample(resv, pathSample, pHat, sampleWeight, sample1f(rng));
        }
        GIReservoirResetIfInvalid(resv);
        GIReservoirCapSample(resv, 40);

        if (GIReservoirIsValid(resv) && resv.sampleCount > 0 && resv.pHat > 1e-6) {
            vec3 primaryWi = normalize(resv.sampledPos - resv.visiblePos);
            radiance = resv.radiance / resv.pHat * resv.resampleWeight / float(resv.sampleCount);
            radiance *= absDot(resv.visibleNorm, primaryWi);
        }
    }
    uGIReservoir[index1D(index)] = resv;

    //radiance = pathSample.radiance;
    radiance *= albedo;
    radiance = clampColor(radiance);

    float frameCount = float(uCamera.frameIndex);
    vec3 accumulatedRadaince = imageLoad(uIndirectOutput, ivec2(index)).rgb;
    accumulatedRadaince = (accumulatedRadaince * frameCount + radiance) / (frameCount + 1.0);

    imageStore(uIndirectOutput, ivec2(index), vec4(accumulatedRadaince, 1.0));
}