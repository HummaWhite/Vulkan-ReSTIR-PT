#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "HostDevice.h"

layout(local_size_x = RayQueryBlockSizeX, local_size_y = RayQueryBlockSizeY) in;

#include "ray_query.glsl"
#include "camera.glsl"
#include "gbuffer_util.glsl"
#include "light_sampling.glsl"
#include "material.glsl"
#include "gris_reservoir.glsl"

struct GRISTraceSettings {
	uint shiftType;
	float rrScale;
};

layout(push_constant) uniform _PushConstant {
    GRISTraceSettings uSettings;
};

#define WRITE_OUTPUT

void main() {
    const int MaxTracingDepth = 15;
    uvec2 threadIdx = gl_GlobalInvocationID.xy;
    uvec2 launchDim = uCamera.filmSize;

    if (threadIdx.x >= launchDim.x || threadIdx.y >= launchDim.y) {
        return;
    }
    vec2 uv = (vec2(threadIdx) + 0.5) / vec2(launchDim);

    vec4 depthNormal = texture(uDepthNormal, uv);
    float depth = depthNormal.x;
    vec3 norm = depthNormal.yzw;

    if (depth == 0.0) {
#ifdef WRITE_OUTPUT
        imageStore(uIndirectOutput, ivec2(threadIdx), vec4(vec3(0.0), 1.0));
#endif
        return;
    }
    uvec2 albedoMatId = texelFetch(uAlbedoMatId, ivec2(threadIdx), 0).rg;
    vec3 albedo = unpackAlbedo(albedoMatId.x);
    int matMeshId = int(albedoMatId.y);
    int matId = matMeshId >> 16;
    
    Ray ray = pinholeCameraSampleRay(uCamera, vec2(uv.x, 1.0 - uv.y), vec2(0));
    uint rng = makeSeed(uCamera.seed + threadIdx.x, threadIdx.y);

    vec3 radiance = vec3(0.0);
    vec3 throughput = vec3(1.0);
    vec3 throughputAfter = vec3(1.0);
    vec3 wo = -ray.dir;
    vec3 lastPos;
    bool isLastVertexConnectible = false;
    bool rcVertexFound = false;
    uint rcVertexId = 0;

    SurfaceInfo surf;
    surf.pos = ray.ori + ray.dir * (depth - 1e-4);
    surf.norm = norm;
    surf.albedo = albedo;
    surf.isLight = false;

    Material mat = uMaterials[matId];
    BSDFSample s;
    Intersection isec;

    GRISPathSample pathSample;
    GRISPathSampleReset(pathSample);
    pathSample.primaryHitRng = rng;

    GRISReservoir resv = uGRISReservoir[index1D(threadIdx)];

    // Target function        - pathSample.F = indirect illumination (full illumination - direct illumination without MIS)
    // Path incident radiance - pathSample.rcVertexWi = 

#pragma unroll
    for (int bounce = 0; bounce < MaxTracingDepth; bounce++) {
        GRISPathFlagsSetPathLength(pathSample.flags, bounce + 1);

        if (bounce > 0) {
            isec = rayQueryTraceClosestHit(
                uTLAS,
                gl_RayFlagsOpaqueEXT, 0xff,
                ray.ori, MinRayDistance, ray.dir, MaxRayDistance
            );

            if (!IntersectionIsValid(isec)) {
                break;
            }
            loadSurfaceInfo(isec, surf);
            mat = uMaterials[surf.matIndex];
        }

        float cosPrevWi = dot(ray.dir, surf.norm);
        float distToPrev = distance(lastPos, surf.pos);
        float geometryJacobian = abs(cosPrevWi) / square(distToPrev);

        if (surf.isLight) {
            if (/* cosPrevWi < 0 */ true) {
                float weight = 1.0;
                float sumPower = uLightSampleTable[0].prob;
                float lightPdf = luminance(surf.albedo) / sumPower / geometryJacobian;

                if (bounce > 0 && !isSampleTypeDelta(s.type)) {
                    weight = MISWeight(s.pdf, lightPdf);
                }
                if (rcVertexFound) {
                    if (bounce == rcVertexId + 1) {
                        // the scattered ray at rcVertex hits a light source
                        pathSample.rcVertexLi = surf.albedo;
                        pathSample.F = surf.albedo * throughput;
                        radiance += surf.albedo * throughput;
                    }
                    else {
                        // the scattered ray after rcVertex indirectly hits a light source
                        pathSample.rcVertexLi += surf.albedo * weight * throughputAfter;
                        pathSample.F += surf.albedo * weight * throughput;
                        radiance += surf.albedo * weight * throughput;
                    }
                }
                else {
                    radiance += surf.albedo * weight * throughput;
                }
            }
        }
        bool isThisVertexConnectible = isBSDFConnectible(mat);

        if (!rcVertexFound && isLastVertexConnectible && isThisVertexConnectible && distToPrev > GRISDistanceThreshold) {
            // found an rcVertex that satisfies connectibility conditions
            // it can either be a regular surface or an emitter:
            //   - if emitter, the emittance is recorded to rcVertexWi and the path is terminated
            //   - if regular surface, the path continues to gather radiance to add to rcVertexWi
            rcVertexFound = true;

            pathSample.rcVertexIsec = isec;
            pathSample.rcVertexRng = rng;
            pathSample.rcPrevScatterPdf = s.pdf;
            pathSample.rcGeometryTerm = geometryJacobian;
            pathSample.rcVertexLi = surf.isLight ? surf.albedo : vec3(0.0);

            rcVertexId = bounce;
            GRISPathFlagsSetRcVertexId(pathSample.flags, rcVertexId);

            if (surf.isLight) {
                GRISPathFlagsSetRcVertexType(pathSample.flags, RcVertexSource);
            }
        }

        if (surf.isLight) {
            break;
        }
        // make sure sample space is aligned for all paths
        vec4 lightRandSample = sample4f(rng);

        if (/* sample direct lighting */ bounce > 0 && !isBSDFDelta(mat)) {
            const uint shadowRayFlags = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT;

            vec3 lightRadiance, lightDir;
            float lightDist, lightPdf;

            lightRadiance = sampleLight(surf.pos, lightDir, lightDist, lightPdf, lightRandSample);

            bool shadowed = rayQueryTraceShadow(
                uTLAS,
                shadowRayFlags, 0xff,
                surf.pos, MinRayDistance, lightDir, lightDist - MinRayDistance
            );

            if (!shadowed && lightPdf > 1e-6) {
                float bsdfPdf = absDot(surf.norm, lightDir) * PiInv;
                float weight = MISWeight(lightPdf, bsdfPdf);
                vec3 lightTerms = lightRadiance * evalBSDF(mat, surf.albedo, surf.norm, wo, lightDir) * satDot(surf.norm, lightDir) / lightPdf;

                if (rcVertexFound) {
                    // if successfully sampled a light source and an rcVertex is found priorly
                    if (bounce == rcVertexId) {
                        // if rcVertex is the same as our reference point, mark its type as direct light sampling at rcVertex (RcVertexDirectLight)
                        // in theory we can continue tracing another BSDF sample (indirect lighting at rcVertex), and do RIS to choose one
                        // for simplicity we can just terminate here
                        // and I doubt if it worths to have multiple sample candidates of longer path, since they are harder to connect to
                        pathSample.rcVertexLi = lightRadiance;
                        pathSample.rcVertexWi = lightDir;
                        pathSample.rcLightPdf = lightPdf;
                        pathSample.F = lightTerms * throughput;

                        GRISPathFlagsSetRcVertexType(pathSample.flags, RcVertexDirectLight);
                        radiance += lightTerms * throughput;
                        break;
                    }
                    else {
                        // otherwise, it is not NEE, we continue the path to collect radiance from lights
                        pathSample.rcVertexLi += lightTerms * weight * throughputAfter;
                        pathSample.F += lightTerms * weight * throughput;
                    }
                }
                radiance += lightTerms * weight * throughput;
            }
        }
        bool skipRouletteForRcVertex = (rcVertexFound && (bounce == rcVertexId));

        if (/* russian roulette */ bounce > 4 && !skipRouletteForRcVertex) {
            float pdfTerminate = max(1.0 - luminance(throughput) * uSettings.rrScale, 0);

            if (sample1f(rng) < pdfTerminate) {
                break;
            }
            throughput /= (1.0 - pdfTerminate);
            throughputAfter /= (1.0 - pdfTerminate);
        }

        if (!sampleBSDF(mat, surf.albedo, surf.norm, wo, sample3f(rng), s) || s.pdf < 1e-6) {
            break;
        }

        float cosTheta = isSampleTypeDelta(s.type) ? 1.0 : absDot(surf.norm, s.wi);
        vec3 scatterTerm = s.bsdf * cosTheta / s.pdf;
        throughput *= scatterTerm;

        if (rcVertexFound) {
            if (bounce == rcVertexId) {
                // if direct light sampling fails at rcVertex, this is a scattered path sample (RcVertexScattered)
                pathSample.rcVertexWi = s.wi;
                pathSample.rcScatterPdf = s.pdf;
                GRISPathFlagsSetRcVertexType(pathSample.flags, RcVertexScattered);
            }
            else {
                throughputAfter *= scatterTerm;
            }
        }

        lastPos = surf.pos;
        wo = -s.wi;
        ray.dir = s.wi;
        ray.ori = surf.pos + ray.dir * 1e-4;
        isLastVertexConnectible = isThisVertexConnectible;
    }
    float pHat = 1.0;
    bool added = GRISReservoirAdd(resv, pathSample.F, pHat, rng);
    GRISReservoirCapSample(resv, 20.0);
    uGRISReservoir[index1D(threadIdx)] = resv;

    uint pathLength = GRISPathFlagsPathLength(pathSample.flags);

    //radiance = colorWheel(float(rcVertexId) / float(pathLength));
    //radiance = colorWheel(float(rcVertexId) / 6.0);
    //radiance = vec3(pathSample.rcScatterPdf);
    //radiance = vec3(GRISPathFlagsRcVertexId(pathSample.flags) == 1);
    //radiance = vec3(pathSample.rcPrevScatterPdf);
    //radiance = colorWheel(pathSample.rcLightPdf);
    //radiance = vec3(pathSample.rcGeometryTerm);
    //radiance = colorWheel(pathSample.rcGeometryTerm);
    //radiance = pathSample.F;
    //radiance = radiance - pathSample.F;
    //radiance = pathSample.rcVertexLi;
    //radiance = colorWheel(float(GRISPathFlagsIsNEE(pathSample.flags)));
    //radiance = vec3(resv.resampleWeight / resv.sampleCount);
    //radiance = colorWheel(float(GRISPathFlagsRcVertexType(pathSample.flags)) / 2.0);
    //radiance = vec3(0.0);

    radiance = clampColor(radiance);
    float frameCount = float(uCamera.frameIndex & CameraFrameIndexMask);
    vec3 accumulatedRadaince = imageLoad(uIndirectOutput, ivec2(threadIdx)).rgb;
    accumulatedRadaince = (accumulatedRadaince * frameCount + radiance) / (frameCount + 1.0);

#ifdef WRITE_OUTPUT
    imageStore(uIndirectOutput, ivec2(threadIdx), vec4(accumulatedRadaince, 1.0));
#endif
}