#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "HostDevice.h"

layout(local_size_x = RayQueryBlockSizeX, local_size_y = RayQueryBlockSizeY) in;

#include "ray_query.glsl"
#include "gris_retrace.glsl"

void main() {
    uvec2 index = gl_GlobalInvocationID.xy;
    uvec2 launchDim = uCamera.filmSize;

    if (index.x >= launchDim.x || index.y >= launchDim.y) {
        return;
    }
    const int MaxTracingDepth = 15;
    vec2 uv = (vec2(index) + 0.5) / vec2(launchDim);

    float depth;
    vec3 norm;
    vec3 albedo;
    int matMeshId;

    if (!unpackGBuffer(texture(uDepthNormal, uv), texelFetch(uAlbedoMatId, ivec2(index), 0), depth, norm, albedo, matMeshId)) {
        imageStore(uIndirectOutput, ivec2(index), vec4(vec3(0.0), 1.0));
        return;
    }
    int matId = matMeshId >> 16;
    
    Ray ray = pinholeCameraSampleRay(uCamera, vec2(uv.x, 1.0 - uv.y), vec2(0));
    uint rng = makeSeed(uCamera.seed + index.x, index.y);

    vec2 motion = texelFetch(uMotionVector, ivec2(index), 0).xy;

    SurfaceInfo surf;
    surf.pos = ray.ori + ray.dir * (depth - 1e-4);
    surf.norm = norm;
    surf.albedo = albedo;
    surf.isLight = false;
    surf.matIndex = matId;

    GRISReservoir resv = uGRISReservoir[index1D(index)];
    GRISReservoir temporalResv;

    if (!findPreviousReservoir(uv + motion, surf.pos, depth, norm, albedo, matMeshId, temporalResv)) {
        imageStore(uIndirectOutput, ivec2(index), vec4(vec3(0.0), 1.0));
        return;
    }

    Intersection rcPrevIsec;
    vec3 rcPrevWo;
    vec3 throughput = traceReplayPathForHybridShift(surf, ray, temporalResv.pathSample.flags, temporalResv.pathSample.primaryRng, rcPrevIsec, rcPrevWo);
    
    imageStore(uIndirectOutput, ivec2(index), vec4(vec3(temporalResv.resampleWeight), 1.0));
}