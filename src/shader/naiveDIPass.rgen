#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "rayTracingLayouts.glsl"
#include "camera.glsl"
#include "GBufferUtil.glsl"
#include "lightSampling.glsl"
#include "math.glsl"

layout(location = 0) rayPayloadEXT Intersection rtIsec;
layout(location = 1) rayPayloadEXT bool rtShadowed;

void main() {
    vec2 uv = (vec2(gl_LaunchIDEXT.xy) + 0.5) / vec2(gl_LaunchSizeEXT.xy);

    uvec4 GBufferThisA = texelFetch(uGBufferThisA, ivec2(gl_LaunchIDEXT.xy), 0);
    uvec4 GBufferThisB = texelFetch(uGBufferThisB, ivec2(gl_LaunchIDEXT.xy), 0);

    vec3 albedo = unpackAlbedo(GBufferThisA.x);
    vec3 norm = uintBitsToFloat(GBufferThisA.yzw);
    float depth = uintBitsToFloat(GBufferThisB.x);
    int matIndex = int(GBufferThisB.y);
    // vec2 motion = unpackSnorm2x16(GBufferThisB.z);

    if (depth == 0.0) {
        imageStore(uDirectOutput, ivec2(gl_LaunchIDEXT.xy), vec4(vec3(0.0), 1.0));
        return;
    }
    
    Ray ray = pinholeCameraSampleRay(uCamera, vec2(uv.x, 1.0 - uv.y), vec2(0));
    uint rng = makeSeed(uCamera.seed + gl_LaunchIDEXT.x, gl_LaunchIDEXT.y);

    vec3 radiance = vec3(0.0);
    vec3 throughput = vec3(1.0);
    vec3 lastPos;
    float lastBsdfPdf;

    SurfaceInfo surf;
    surf.pos = ray.ori + ray.dir * (depth - 1e-4);
    surf.norm = norm;
    surf.albedo = albedo;
    surf.lightIndex = InvalidResourceIdx;
    rtIsec.hit = true;

    if (/* sample direct lighting */ true)
    {
        const uint shadowRayFlags = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT;

        vec3 lightRadiance, lightDir;
        float lightDist, lightPdf;

        rtShadowed = true;
        lightRadiance = sampleLight(surf.pos, lightDir, lightDist, lightPdf, rng);

        traceRayEXT(
            /* AS, flags, masks    */ uTLAS, shadowRayFlags, 0xff,
            /* SBT offset & stride */ 0, 0,
            /* miss index          */ 1,
            /* ray attribs         */ surf.pos, MinRayDistance, lightDir, lightDist - 1e-4,
            /* payload location    */ 1
        );

        if (!rtShadowed && lightPdf > 1e-6) {
            float bsdfPdf = absDot(surf.norm, lightDir) * PiInv;
            float weight = MISWeight(lightPdf, bsdfPdf);
            radiance += lightRadiance * (surf.albedo * PiInv) * satDot(surf.norm, lightDir) / lightPdf * weight * throughput;
        }
    }
    imageStore(uDirectOutput, ivec2(gl_LaunchIDEXT.xy), vec4(radiance, 1.0));
}