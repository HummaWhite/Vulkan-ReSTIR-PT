#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "HostDevice.h"

layout(local_size_x = RayQueryBlockSizeX, local_size_y = RayQueryBlockSizeY) in;

#include "ray_query.glsl"
#include "camera.glsl"
#include "gbuffer_util.glsl"
#include "light_sampling.glsl"
#include "math.glsl"

vec3 BSDFDot(vec3 albedo, vec3 n, vec3 wi) {
    return albedo * PiInv * satDot(n, wi);
}

void main() {
    const int MaxTracingDepth = 3;
    uvec2 threadIdx = gl_GlobalInvocationID.xy;
    uvec2 launchDim = uCamera.filmSize;

    if (threadIdx.x >= launchDim.x || threadIdx.y >= launchDim.y) {
        return;
    }
    vec2 uv = (vec2(threadIdx) + 0.5) / vec2(launchDim);

    vec4 depthNormal = texture(uDepthNormal, uv);
    float depth = depthNormal.x;
    vec3 norm = depthNormal.yzw;

    if (depth == 0.0) {
        imageStore(uIndirectOutput, ivec2(threadIdx), vec4(vec3(0.0), 1.0));
        return;
    }
    uvec2 albedoMatId = texelFetch(uAlbedoMatId, ivec2(threadIdx), 0).rg;
    vec3 albedo = unpackAlbedo(albedoMatId.x);
    int matMeshId = int(albedoMatId.y);
    int matId = matMeshId >> 16;
    
    Ray ray = pinholeCameraSampleRay(uCamera, vec2(uv.x, 1.0 - uv.y), vec2(0));
    uint rng = makeSeed(uCamera.seed + threadIdx.x, threadIdx.y);

    vec3 radiance = vec3(0.0);
    vec3 throughput = vec3(1.0);
    vec3 lastPos;
    float lastBsdfPdf;

    SurfaceInfo surf;
    surf.pos = ray.ori + ray.dir * (depth - 1e-4);
    surf.norm = norm;
    surf.albedo = albedo;
    surf.isLight = false;

#pragma unroll
    for (int bounce = 0; bounce < MaxTracingDepth; bounce++) {
        if (bounce > 0) {
            Intersection isec = rayQueryTrace(
                gl_RayFlagsOpaqueEXT, 0xff,
                ray.ori, MinRayDistance, ray.dir, MaxRayDistance
            );

            if (!isec.hit) {
                break;
            }
            loadSurfaceInfo(isec, surf);
        }

        if (surf.isLight) {
            float cosTheta = -dot(ray.dir, surf.norm);

            if (cosTheta > 0) {
                float weight = 1.0;

                if (bounce > 0) {
                    float dist = length(surf.pos - lastPos);
                    float sumPower = uLightSampleTable[0].prob;
                    float lightPdf = luminance(surf.albedo) / sumPower * dist * dist / cosTheta;
                    weight = MISWeight(lastBsdfPdf, lightPdf);
                }
                radiance += surf.albedo * weight * throughput;
            }
            break;
        }

        if (/* sample direct lighting */ true) {
            const uint shadowRayFlags = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT;

            vec3 lightRadiance, lightDir;
            float lightDist, lightPdf;

            lightRadiance = sampleLight(surf.pos, lightDir, lightDist, lightPdf, rng);

            bool shadowed = rayQueryTraceShadow(
                shadowRayFlags, 0xff,
                surf.pos, MinRayDistance, lightDir, lightDist - 1e-4
            );

            if (!shadowed && lightPdf > 1e-6) {
                float bsdfPdf = absDot(surf.norm, lightDir) * PiInv;
                float weight = MISWeight(lightPdf, bsdfPdf);
                radiance += lightRadiance * (surf.albedo * PiInv) * satDot(surf.norm, lightDir) / lightPdf * weight * throughput;
            }
        }

        ray.dir = sampleCosineWeightedHemisphere(surf.norm, sample2f(rng));
        ray.ori = surf.pos + ray.dir * 1e-4;
        throughput *= surf.albedo;
        lastBsdfPdf = absDot(surf.norm, ray.dir) * PiInv;
        lastPos = surf.pos;
    }
    float frameCount = float(uCamera.frameIndex);
    vec3 accumulatedRadaince = imageLoad(uIndirectOutput, ivec2(threadIdx)).rgb;
    accumulatedRadaince = (accumulatedRadaince * frameCount + radiance) / (frameCount + 1.0);

    imageStore(uIndirectOutput, ivec2(threadIdx), vec4(accumulatedRadaince, 1.0));
}