#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "rayTracingLayouts.glsl"
#include "camera.glsl"
#include "GBufferUtil.glsl"

layout(location = 0) rayPayloadEXT RTPayload rtPayload;

void main() {
    uvec4 GBufferA = texelFetch(uGBufferA, ivec2(gl_LaunchIDEXT.xy), 0);
    uvec4 GBufferB = texelFetch(uGBufferB, ivec2(gl_LaunchIDEXT.xy), 0);

    vec2 uv = (vec2(gl_LaunchIDEXT.xy) + 0.5) / vec2(gl_LaunchSizeEXT.xy);

    rtPayload.rng = makeSeed(uCamera.seed0, uCamera.seed1, gl_LaunchIDEXT.x * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.y);
    rtPayload.throughput = vec3(1.0);
    rtPayload.radiance = vec3(0.0);
    rtPayload.curDepth = 0;

    Ray ray = thinLensCameraSampleRay(uCamera, vec2(uv.x, 1.0 - uv.y), vec4(0.5, 0.5, 0, 0));

    traceRayEXT(
        /* accelerationStructureEXT TLAS */ uTLAS,
        /* uint rayFlags                 */ gl_RayFlagsOpaqueEXT,
        /* uint cullMask                 */ 0xff,
        /* uint sbtRecordOffset          */ 0,
        /* uint sbtRecordStride          */ 0,
        /* uint missIndex                */ 0,
        /* vec3 rayOrigin                */ ray.ori,
        /* float minDistance             */ MinRayDistance,
        /* vec3 rayDirection             */ ray.dir,
        /* float maxDistance             */ MaxRayDistance,
        /* uint payloadLocation          */ 0
    );
    
    vec3 color = rtPayload.radiance;
    //vec3 color = vec3(uv, 0.5);
    //vec3 color = unpackAlbedo(GBufferA.x);
    //vec3 color = vec3(uintBitsToFloat(GBufferB.xy), 0.0);

    imageStore(uRayColorOutput, ivec2(gl_LaunchIDEXT.xy), vec4(color, 1.0));
}